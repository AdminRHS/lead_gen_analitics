<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lead Generation Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script type="module" src="./charts.js"></script>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      background: #fafafa;
      margin: 30px;
    }
    h1 {
      text-align: center;
      margin-bottom: 10px;
    }
    #update {
      text-align: center;
      color: gray;
      margin-bottom: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    .cache-indicator {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 4px;
      background: #e3f2fd;
      color: #1976d2;
      border: 1px solid #90caf9;
    }
    .cache-indicator.server {
      background: #f3e5f5;
      color: #7b1fa2;
      border-color: #ce93d8;
    }
    .refresh-btn {
      padding: 4px 12px;
      font-size: 12px;
      border-radius: 4px;
      border: 1px solid #ddd;
      background: #fff;
      color: #333;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .refresh-btn:hover {
      background: #f5f5f5;
      border-color: #bbb;
    }
    .refresh-btn:active {
      transform: scale(0.98);
    }
    .refresh-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    /* Loading spinner */
    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(0,0,0,0.1);
      border-radius: 50%;
      border-top-color: #336dff;
      animation: spin 0.8s linear infinite;
      margin-right: 8px;
      vertical-align: middle;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .error-message {
      color: #d32f2f;
      background: #ffebee;
      padding: 12px 16px;
      border-radius: 8px;
      border: 1px solid #ffcdd2;
      margin: 20px auto;
      max-width: 600px;
    }
    .error-message::before {
      content: "‚ö†Ô∏è ";
      margin-right: 4px;
    }
    .loading-container {
      text-align: center;
      padding: 40px;
      color: #666;
    }
    .chart-container {
      max-width: 900px;
      margin: 40px auto;
      background: white;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    .controls {
      max-width: 1200px;
      margin: 10px auto 30px auto;
      display: flex;
      gap: 16px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      background: #ffffff;
      border-radius: 12px;
      padding: 16px 20px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.06);
      border: 1px solid #eee;
    }
    /* Tabs */
    .tabs {
      max-width: 1240px;
      margin: 0 auto 16px auto;
      display: flex;
      gap: 8px;
      border-bottom: 1px solid #eee;
    }
    .tab {
      padding: 10px 14px;
      border: 1px solid #eee;
      border-bottom: none;
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
      background: #f7f8fb;
      color: #333;
      cursor: pointer;
      font-weight: 600;
    }
    .tab.active { background: #fff; color: #111; box-shadow: 0 -2px 8px rgba(0,0,0,0.04); }
    .tabpanels { 
      max-width: 1240px; 
      margin: 0 auto; 
      position: relative;
    }
    .tabpanel { 
      display: none;
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    .tabpanel.active { 
      display: block;
      opacity: 1;
      transform: translateY(0);
    }
    .controls-left,
    .controls-right {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }
    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .field label {
      font-size: 12px;
      color: #555;
    }
    .input {
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid #dcdcdc;
      background: #fff;
      font-size: 14px;
      transition: border-color 0.15s ease, box-shadow 0.15s ease;
    }
    .input:focus {
      outline: none;
      border-color: #7aa7ff;
      box-shadow: 0 0 0 3px rgba(84,132,255,0.2);
    }
    .btn {
      padding: 10px 14px;
      border-radius: 8px;
      border: 1px solid transparent;
      font-weight: 600;
      cursor: pointer;
      font-size: 14px;
      transition: transform 0.05s ease, box-shadow 0.15s ease, background-color 0.15s ease, color 0.15s ease;
    }
    .btn:active { transform: translateY(1px); }
    .btn-primary {
      background: linear-gradient(180deg, #4f8bff, #336dff);
      color: #fff;
      box-shadow: 0 6px 16px rgba(51,109,255,0.25);
    }
    .btn-primary:hover { filter: brightness(1.05); }
    .btn-secondary {
      background: #fff;
      color: #333;
      border-color: #dcdcdc;
    }
    .btn-secondary:hover {
      background: #f6f8ff;
      border-color: #c8d6ff;
    }
    /* Modal and overlay */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(2px);
      display: none;
      align-items: flex-start;
      justify-content: center;
      z-index: 1000;
      overflow-y: auto;
      padding: 20px;
      transition: background 0.2s ease, backdrop-filter 0.2s ease;
    }
    .modal {
      width: min(900px, 92vw);
      max-height: calc(100vh - 40px);
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 12px 36px rgba(0,0,0,0.25);
      overflow: hidden;
      border: 1px solid #eee;
      margin: auto;
      display: flex;
      flex-direction: column;
    }
    .modal-body {
      padding: 16px;
      overflow-y: auto;
      flex: 1;
    }
    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-bottom: 1px solid #f0f0f0;
      background: #fafafa;
    }
    .modal-title { font-weight: 700; color: #333; }
    .modal-actions { padding: 12px 16px; border-top: 1px solid #f0f0f0; display: flex; justify-content: flex-end; gap: 10px; }
    .link-btn { background: transparent; border: none; color: #336dff; cursor: pointer; font-weight: 600; }
    .link-btn:hover { text-decoration: underline; }
    .summary-controls { display: flex; gap: 12px; align-items: center; margin-bottom: 12px; }
    .summary-table { width: 100%; border-collapse: collapse; }
    .summary-table th, .summary-table td { padding: 8px 10px; border-bottom: 1px solid #f0f0f0; text-align: right; }
    .summary-table th:first-child, .summary-table td:first-child { text-align: left; }
    .summary-table tfoot td { font-weight: 700; }
    .dashboard-grid {
      display: grid;
      gap: 24px;
      grid-template-columns: repeat(2, minmax(520px, 1fr));
      max-width: 1200px;
      margin: 0 auto;
    }
    @media (max-width: 1200px) {
      .dashboard-grid { grid-template-columns: repeat(2, minmax(420px, 1fr)); }
    }
    @media (max-width: 900px) {
      .dashboard-grid { grid-template-columns: 1fr; }
    }
    .dashboard-grid .chart-card {
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      padding: 16px;
    }
    /* Soft themed cards (very light pastels) */
    .chart-card.soft-blue { background: linear-gradient(180deg, #f6f9ff, #ffffff); border: 1px solid #e6edff; }
    .chart-card.soft-purple { background: linear-gradient(180deg, #faf6ff, #ffffff); border: 1px solid #eee6ff; }
    .chart-card.soft-green { background: linear-gradient(180deg, #f6fffb, #ffffff); border: 1px solid #e6fff3; }
    .chart-card.soft-yellow { background: linear-gradient(180deg, #fffdf6, #ffffff); border: 1px solid #fff5d6; }
    .chart-card.soft-pink { background: linear-gradient(180deg, #fff6fb, #ffffff); border: 1px solid #ffe6f3; }

    /* Elegant section divider */
    .section-break {
      max-width: 1240px;
      margin: 28px auto 18px auto;
      height: 1px;
      background: linear-gradient(90deg, rgba(0,0,0,0.06), rgba(0,0,0,0.02) 40%, rgba(0,0,0,0.02) 60%, rgba(0,0,0,0.06));
      position: relative;
    }
    .section-break .label {
      position: absolute;
      top: -12px;
      left: 50%;
      transform: translateX(-50%);
      background: #fafafa;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #eee;
      font-size: 12px;
      color: #666;
    }
    /* Ensure monthly tab charts have explicit height to avoid 0px when toggled */
    /* Fix chart growth/responsive loops by giving explicit canvas height everywhere */
    .chart-card canvas { height: 380px !important; width: 100% !important; display: block; }
    .chart-card h3 {
      margin: 0 0 12px 0;
      font-size: 16px;
      color: #333;
    }
  </style>
</head>
<body>
  <h1>Lead Generation Dashboard</h1>
  <div id="update">Loading...</div>
  <div class="controls">
    <div class="controls-left">
      <div class="field">
        <label for="fromDate">From</label>
        <input type="date" id="fromDate" class="input">
      </div>
      <div class="field">
        <label for="toDate">To</label>
        <input type="date" id="toDate" class="input">
      </div>
    </div>
    <div class="controls-right">
      <button id="openDaySummary" class="btn btn-secondary">Day Summary</button>
      <button id="applyFilter" class="btn btn-primary">Apply</button>
      <button id="resetFilter" class="btn btn-secondary">Reset</button>
    </div>
  </div>
  <div class="tabs" role="tablist">
    <button class="tab active" role="tab" aria-selected="true" aria-controls="tab-funnel" id="tab-funnel-btn">Funnel</button>
    <button class="tab" role="tab" aria-selected="false" aria-controls="tab-country" id="tab-country-btn">Countries</button>
    <button class="tab" role="tab" aria-selected="false" aria-controls="tab-weekly" id="tab-weekly-btn">Weekly</button>
    <button class="tab" role="tab" aria-selected="false" aria-controls="tab-monthly" id="tab-monthly-btn">Monthly</button>
    <button class="tab" role="tab" aria-selected="false" aria-controls="tab-leaderboard" id="tab-leaderboard-btn">Leaderboard</button>
    <button class="tab" role="tab" aria-selected="false" aria-controls="tab-source" id="tab-source-btn">Source Comparison</button>
    
  </div>

  <div class="tabpanels">
  <div id="tab-funnel" class="tabpanel active" role="tabpanel" aria-labelledby="tab-funnel-btn">
  <div class="dashboard-grid">
    <div class="chart-card soft-blue">
      <h3>Created ‚Üí Sent Requests</h3>
      <canvas id="chartCreatedToFound"></canvas>
    </div>
    <div class="chart-card soft-purple">
      <h3>Sent Requests ‚Üí Connected</h3>
      <canvas id="chartSentToConnected"></canvas>
    </div>
    <div class="chart-card soft-green">
      <h3>Connected ‚Üí Replies</h3>
      <canvas id="chartConnectedToReplies"></canvas>
    </div>
    <div class="chart-card soft-yellow">
      <h3>Replies ‚Üí Positive Replies</h3>
      <canvas id="chartRepliesToPositive"></canvas>
    </div>
    <div class="chart-card soft-pink">
      <h3>Positive Replies ‚Üí Events</h3>
      <canvas id="chartPositiveToEvents"></canvas>
    </div>
  </div>
  </div>

  <div id="tab-country" class="tabpanel" role="tabpanel" aria-labelledby="tab-country-btn">
  <div class="dashboard-grid" id="countryDashboard">
    <div class="chart-card soft-blue">
      <h3>Conversion Rate (Created ‚Üí Events) by Country</h3>
      <canvas id="chartCountryConversionRate"></canvas>
    </div>
    <div class="chart-card soft-blue">
      <h3>Created ‚Üí Sent Requests (by Country)</h3>
      <canvas id="chartCountryCreatedToFound"></canvas>
    </div>
    <div class="chart-card soft-purple">
      <h3>Sent Requests ‚Üí Connected (by Country)</h3>
      <canvas id="chartCountrySentToConnected"></canvas>
    </div>
    <div class="chart-card soft-green">
      <h3>Connected ‚Üí Replies (by Country)</h3>
      <canvas id="chartCountryConnectedToReplies"></canvas>
    </div>
    <div class="chart-card soft-yellow">
      <h3>Replies ‚Üí Positive Replies (by Country)</h3>
      <canvas id="chartCountryRepliesToPositive"></canvas>
    </div>
    <div class="chart-card soft-pink">
      <h3>Positive Replies ‚Üí Events (by Country)</h3>
      <canvas id="chartCountryPositiveToEvents"></canvas>
    </div>
  </div>
  </div>
  <div id="tab-weekly" class="tabpanel" role="tabpanel" aria-labelledby="tab-weekly-btn">
  <div class="dashboard-grid">
    <div class="chart-card soft-blue">
      <h3>Weekly: Created ‚Üí Sent Requests</h3>
      <canvas id="chartWeekCreatedToFound"></canvas>
    </div>
    <div class="chart-card soft-purple">
      <h3>Weekly: Sent Requests ‚Üí Connected</h3>
      <canvas id="chartWeekSentToConnected"></canvas>
    </div>
    <div class="chart-card soft-green">
      <h3>Weekly: Connected ‚Üí Replies</h3>
      <canvas id="chartWeekConnectedToReplies"></canvas>
    </div>
    <div class="chart-card soft-yellow">
      <h3>Weekly: Replies ‚Üí Positive Replies</h3>
      <canvas id="chartWeekRepliesToPositive"></canvas>
    </div>
    <div class="chart-card soft-pink">
      <h3>Weekly: Positive Replies ‚Üí Events</h3>
      <canvas id="chartWeekPositiveToEvents"></canvas>
    </div>
  </div>
  </div>
  <div id="tab-monthly" class="tabpanel" role="tabpanel" aria-labelledby="tab-monthly-btn">
  <div class="dashboard-grid">
    <div class="chart-card soft-blue">
      <h3>Monthly: Conversion Rate (Created ‚Üí Events)</h3>
      <canvas id="chartMonthConversionRate"></canvas>
    </div>
    <div class="chart-card soft-blue">
      <h3>Monthly: Created ‚Üí Sent Requests</h3>
      <canvas id="chartMonthCreatedToFound"></canvas>
    </div>
    <div class="chart-card soft-purple">
      <h3>Monthly: Sent Requests ‚Üí Connected</h3>
      <canvas id="chartMonthSentToConnected"></canvas>
    </div>
    <div class="chart-card soft-green">
      <h3>Monthly: Connected ‚Üí Replies</h3>
      <canvas id="chartMonthConnectedToReplies"></canvas>
    </div>
    <div class="chart-card soft-yellow">
      <h3>Monthly: Replies ‚Üí Positive Replies</h3>
      <canvas id="chartMonthRepliesToPositive"></canvas>
    </div>
    <div class="chart-card soft-pink">
      <h3>Monthly: Positive Replies ‚Üí Events</h3>
      <canvas id="chartMonthPositiveToEvents"></canvas>
    </div>
  </div>
  </div>

  <div id="tab-leaderboard" class="tabpanel" role="tabpanel" aria-labelledby="tab-leaderboard-btn">
  <div class="dashboard-grid">
    <div class="chart-card soft-blue">
      <h3>Conversion Rate (Created ‚Üí Events) by Lead Generator</h3>
      <canvas id="chartLbConversionRate"></canvas>
    </div>
    <div class="chart-card soft-blue">
      <h3>Created by Lead Generator (month/range)</h3>
      <canvas id="chartLbCreated"></canvas>
    </div>
    <div class="chart-card soft-purple">
      <h3>Sent Requests by Lead Generator</h3>
      <canvas id="chartLbSent"></canvas>
    </div>
    <div class="chart-card soft-green">
      <h3>Positive Replies by Lead Generator</h3>
      <canvas id="chartLbPositive"></canvas>
    </div>
    <div class="chart-card soft-yellow">
      <h3>Events Created by Lead Generator</h3>
      <canvas id="chartLbEvents"></canvas>
    </div>
  </div>
  </div>
  </div>
  </div>

  <div id="tab-source" class="tabpanel" role="tabpanel" aria-labelledby="tab-source-btn">
  <div class="dashboard-grid">
    <div class="chart-card soft-blue">
      <h3>Source Comparison: Conversion Rate (Created ‚Üí Events)</h3>
      <canvas id="chartSourceConversionRate"></canvas>
    </div>
    <div class="chart-card soft-blue">
      <h3>Source Comparison: Created ‚Üí Sent Requests</h3>
      <canvas id="chartSourceCreatedToSent"></canvas>
    </div>
    <div class="chart-card soft-purple">
      <h3>Source Comparison: Sent Requests ‚Üí Connected</h3>
      <canvas id="chartSourceSentToConnected"></canvas>
    </div>
    <div class="chart-card soft-green">
      <h3>Source Comparison: Connected ‚Üí Total Replies</h3>
      <canvas id="chartSourceConnectedToReplies"></canvas>
    </div>
    <div class="chart-card soft-orange">
      <h3>Source Comparison: Total Replies ‚Üí Positive Replies</h3>
      <canvas id="chartSourceRepliesToPositive"></canvas>
    </div>
    <div class="chart-card soft-red">
      <h3>Source Comparison: Positive Replies ‚Üí Events</h3>
      <canvas id="chartSourcePositiveToEvents"></canvas>
    </div>
  </div>
  </div>

  <!-- Modal for single-day summary -->
  <div class="modal-overlay" id="dayModalOverlay">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="dayModalTitle">
      <div class="modal-header">
        <div class="modal-title" id="dayModalTitle">Day Summary</div>
        <button id="closeDayModal" class="link-btn">Close</button>
      </div>
      <div class="modal-body">
        <div class="summary-controls">
          <label for="dayPicker">Pick a date:</label>
          <input type="date" id="dayPicker" class="input">
        </div>
        <div class="sort-controls" style="margin: 10px 0;">
          <label for="sortColumn">Sort by:</label>
          <select id="sortColumn" class="input">
            <option value="Created">Created</option>
            <option value="SentRequests">Sent Requests</option>
            <option value="Connected">Connected</option>
            <option value="PositiveReplies">Positive Replies</option>
            <option value="Events">Events</option>
          </select>
          <button id="sortButton" class="btn btn-secondary">Sort</button>
        </div>
        <div id="daySummaryContainer"></div>
      </div>
      <div class="modal-actions">
        <button id="exportDayCsv" class="btn btn-secondary">Export CSV</button>
        <button id="doneDay" class="btn btn-primary">Done</button>
      </div>
    </div>
  </div>

  <!-- Modal for Country Insight -->
  <div class="modal-overlay" id="countryModalOverlay">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="countryModalTitle">
      <div class="modal-header">
        <div class="modal-title" id="countryModalTitle">Country Insight</div>
        <button id="closeCountryModal" class="link-btn">Close</button>
      </div>
      <div class="modal-body">
        <div id="countrySummary"></div>
        <div class="dashboard-grid" style="grid-template-columns: 1fr;">
          <div class="chart-card soft-blue">
            <h3>Monthly Created vs Events</h3>
            <canvas id="countryMonthlyPaired"></canvas>
          </div>
        </div>
        <div id="countryTopGenerators"></div>
      </div>
      <div class="modal-actions">
        <button id="doneCountry" class="btn btn-primary">Done</button>
      </div>
    </div>
  </div>

  <!-- Modal for Lead Generator Insight -->
  <div class="modal-overlay" id="leadModalOverlay">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="leadModalTitle">
      <div class="modal-header">
        <div class="modal-title" id="leadModalTitle">Lead Insight</div>
        <button id="closeLeadModal" class="link-btn">Close</button>
      </div>
      <div class="modal-body">
        <div id="leadSummary"></div>
        <div class="dashboard-grid" style="grid-template-columns: 1fr;">
          <div class="chart-card soft-blue">
            <h3>Monthly Created vs Events</h3>
            <canvas id="leadMonthlyPaired"></canvas>
          </div>
        </div>
        <div id="leadTopCountries"></div>
      </div>
      <div class="modal-actions">
        <button id="doneLead" class="btn btn-primary">Done</button>
      </div>
    </div>
  </div>

  <script type="module">
    import { renderPairedBarChart, renderSingleBarChart, renderConversionRateChart } from './charts.js';
    import { parseDdMmYyyyToDate, toIsoDateInputValue, validateData, destroyIfExists, getIsoWeekInfo } from './utils.js';
    import { buildAggregates, buildCountryAggregates, buildWeeklyAggregates, buildMonthlyAggregates, buildLeaderboardAggregates, buildSourceAggregates } from './aggregates.js';
    import { getCachedData, setCachedData, isCacheValid, clearCache, getCacheInfo, isLocalStorageAvailable } from './cache.js';
    import { 
      getDataHash, 
      shouldRecalculateAggregations, 
      updateAggregationCache, 
      updatePairedBarChart, 
      updateSingleBarChart,
      debounce,
      scheduleChartUpdate,
      batchChartUpdates
    } from './chartOptimizer.js';

    // Shared state across tabs/renderers
    let chartRefs = {
      createdFound: null,
      sentConnected: null,
      connectedReplies: null,
      repliesPositive: null,
      positiveEvents: null,
      // Countries (new paired charts)
      countryCreatedFound: null,
      countrySentConnected: null,
      countryConnectedReplies: null,
      countryRepliesPositive: null,
      countryPositiveEvents: null,
      // Countries (legacy single charts, kept for safety)
      countryConnected: null,
      countryReplies: null,
      countryPositive: null,
      countryEvents: null,
      weekCreatedFound: null,
      weekSentConnected: null,
      weekConnectedReplies: null,
      weekRepliesPositive: null,
      weekPositiveEvents: null,
      monthCreatedFound: null,
      monthSentConnected: null,
      monthConnectedReplies: null,
      monthRepliesPositive: null,
      monthPositiveEvents: null
    };
    // Leaderboard chart refs
    chartRefs.lbCreated = null;
    chartRefs.lbSent = null;
    chartRefs.lbPositive = null;
    chartRefs.lbEvents = null;
    // Conversion rate chart refs
    chartRefs.monthConversionRate = null;
    chartRefs.countryConversionRate = null;
    chartRefs.lbConversionRate = null;
    // Country modal chart ref
    chartRefs.countryMonthlyPaired = null;
    // Lead modal chart ref
    chartRefs.leadMonthlyPaired = null;
    // Source comparison chart refs
    chartRefs.sourceConversionRate = null;
    chartRefs.sourceCreatedToSent = null;
    chartRefs.sourceSentToConnected = null;
    chartRefs.sourceConnectedToReplies = null;
    chartRefs.sourceRepliesToPositive = null;
    chartRefs.sourcePositiveToEvents = null;
    let lastFilteredRows = [];
    let rerenderAll = null; // will be assigned inside initDashboard
    let currentDayData = null; // –¥–ª—è –∑–±–µ—Ä—ñ–≥–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö –ø–æ—Ç–æ—á–Ω–æ–≥–æ –¥–Ω—è –¥–ª—è —Å–æ—Ä—Ç—É–≤–∞–Ω–Ω—è
    
    // Aggregation cache for performance optimization
    const aggregationCache = {
      dataHash: null,
      lastFilteredRows: null,
      funnel: null,
      country: null,
      weekly: null,
      monthly: null,
      leaderboard: null,
      source: null
    };
    
    // Track which tabs have been rendered
    const renderedTabs = {
      funnel: false,
      country: false,
      weekly: false,
      monthly: false,
      leaderboard: false,
      source: false
    };
    
    // Cache DOM elements for better performance
    const chartElements = {};

    // Helper function to fetch data from server
    async function fetchDataFromServer() {
      const res = await fetch("data.json");
      
      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status} ${res.statusText}`);
      }
      
      let json;
      try {
        json = await res.json();
      } catch (parseError) {
        throw new Error(`Failed to parse JSON: ${parseError.message}`);
      }
      
      // Validate data structure
      validateData(json);
      
      return json;
    }

    // Helper function to update UI with data source indicator
    function updateStatusUI(updateEl, json, fromCache = false) {
      const statusText = `Last updated: ${json.last_updated || 'Unknown'}`;
      const indicator = fromCache 
        ? '<span class="cache-indicator">üì¶ –ó –∫–µ—à—É</span>'
        : '<span class="cache-indicator server">üîÑ –ó —Å–µ—Ä–≤–µ—Ä–∞</span>';
      const refreshBtn = '<button class="refresh-btn" id="refreshDataBtn" title="–û–Ω–æ–≤–∏—Ç–∏ –¥–∞–Ω—ñ">üîÑ</button>';
      
      updateEl.innerHTML = `<span>${statusText}</span>${indicator}${refreshBtn}`;
      
      // Attach refresh button handler
      const refreshBtnEl = document.getElementById('refreshDataBtn');
      if (refreshBtnEl) {
        refreshBtnEl.addEventListener('click', handleManualRefresh);
      }
    }

    // Handle manual refresh button click
    async function handleManualRefresh() {
      const updateEl = document.getElementById("update");
      const refreshBtn = document.getElementById('refreshDataBtn');
      
      if (refreshBtn) {
        refreshBtn.disabled = true;
        refreshBtn.textContent = '‚è≥';
      }
      
      try {
        const json = await fetchDataFromServer();
        if (isLocalStorageAvailable()) {
          setCachedData(json);
        }
        processDashboardData(json);
        await initializeDashboardWithData(json);
        updateStatusUI(updateEl, json, false);
      } catch (error) {
        console.error('Error refreshing data:', error);
        // Show error but don't break the UI
        if (refreshBtn) {
          refreshBtn.textContent = '‚ùå';
          setTimeout(() => {
            refreshBtn.textContent = 'üîÑ';
            refreshBtn.disabled = false;
          }, 2000);
        }
      } finally {
        if (refreshBtn) {
          refreshBtn.disabled = false;
        }
      }
    }

    // Background update check (silent)
    async function updateDataInBackground() {
      try {
        const json = await fetchDataFromServer();
        const cached = getCachedData();
        
        // Only update if server has newer data
        if (!cached || !isCacheValid(cached.last_updated, json.last_updated)) {
          if (isLocalStorageAvailable()) {
            setCachedData(json);
          }
          // Silently update the dashboard if user is still on the page
          processDashboardData(json);
          await initializeDashboardWithData(json);
          const updateEl = document.getElementById("update");
          if (updateEl) {
            updateStatusUI(updateEl, json, false);
          }
        }
      } catch (error) {
        // Silent fail for background updates
        console.debug('Background update failed:', error);
      }
    }

    // Process dashboard data (extracted for reuse)
    function processDashboardData(json) {
      const rows = json.data;
      
      // Hide any error messages
      const existingError = document.querySelector('.error-message');
      if (existingError) {
        existingError.remove();
      }

      // Precompute min/max dates for controls
      const datesList = rows
        .map(r => parseDdMmYyyyToDate(r.Date))
        .filter(Boolean)
        .sort((a,b) => a - b);
      const minDate = datesList[0] || new Date();
      const maxDate = datesList[datesList.length - 1] || new Date();

      const fromEl = document.getElementById('fromDate');
      const toEl = document.getElementById('toDate');
      if (fromEl && toEl) {
        fromEl.value = toIsoDateInputValue(minDate);
        toEl.value = toIsoDateInputValue(maxDate);
      }
    }

    // Initialize dashboard with caching support
    async function initDashboard() {
      const updateEl = document.getElementById("update");
      
      // Check if localStorage is available
      if (!isLocalStorageAvailable()) {
        console.warn('localStorage is not available, caching disabled');
      }
      
      let json;
      let fromCache = false;
      
      // Try to get data from cache first
      if (isLocalStorageAvailable()) {
        const cached = getCachedData();
        
        if (cached && cached.data) {
          console.log('Using cached data:', {
            last_updated: cached.last_updated,
            cached_at: cached.cached_at
          });
          
          // Use cached data for immediate display
          json = cached.data;
          fromCache = true;
          updateStatusUI(updateEl, json, true);
          
          // Process cached data immediately
          processDashboardData(json);
          
          // Start background update check
          setTimeout(() => {
            updateDataInBackground();
          }, 1000); // Wait 1 second before background check
          
          // Continue with dashboard initialization using cached data
          await initializeDashboardWithData(json);
          return;
        } else {
          console.log('No valid cache found, will fetch from server');
        }
      }
      
      // No cache available, fetch from server
      updateEl.innerHTML = '<span class="spinner"></span>–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö...';
      
      try {
        json = await fetchDataFromServer();
        
        // Save to cache if localStorage is available
        if (isLocalStorageAvailable()) {
          const cached = setCachedData(json);
          if (cached) {
            console.log('Data saved to cache successfully');
          } else {
            console.warn('Failed to save data to cache');
          }
        }
        
        updateStatusUI(updateEl, json, false);
        processDashboardData(json);
        await initializeDashboardWithData(json);
        
      } catch (error) {
        // If server fetch fails, try to use cache as fallback
        console.error('Error fetching data from server:', error);
        
        if (isLocalStorageAvailable()) {
          const cached = getCachedData();
          if (cached && cached.data) {
            console.log('Using cached data as fallback');
            json = cached.data;
            fromCache = true;
            updateStatusUI(updateEl, json, true);
            processDashboardData(json);
            await initializeDashboardWithData(json);
            
            // Show warning about using cached data
            const warningDiv = document.createElement('div');
            warningDiv.className = 'error-message';
            warningDiv.style.background = '#fff3cd';
            warningDiv.style.borderColor = '#ffc107';
            warningDiv.innerHTML = `
              <strong>‚ö†Ô∏è –£–≤–∞–≥–∞</strong><br>
              –ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –¥–∞–Ω—ñ –∑ —Å–µ—Ä–≤–µ—Ä–∞. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å—Å—è –∑–∞–∫–µ—à–æ–≤–∞–Ω—ñ –¥–∞–Ω—ñ.<br>
              <small>–°–ø—Ä–æ–±—É–π—Ç–µ –æ–Ω–æ–≤–∏—Ç–∏ —Å—Ç–æ—Ä—ñ–Ω–∫—É –∞–±–æ –Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É –æ–Ω–æ–≤–ª–µ–Ω–Ω—è.</small>
            `;
            document.body.insertBefore(warningDiv, document.querySelector('.controls'));
            return;
          }
        }
        
        // No cache available, show error
        updateEl.innerHTML = '';
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.innerHTML = `
          <strong>–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö</strong><br>
          ${error.message}<br>
          <small>–ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –∫–æ–Ω—Å–æ–ª—å –±—Ä–∞—É–∑–µ—Ä–∞ –¥–ª—è –¥–µ—Ç–∞–ª–µ–π. –°–ø—Ä–æ–±—É–π—Ç–µ –æ–Ω–æ–≤–∏—Ç–∏ —Å—Ç–æ—Ä—ñ–Ω–∫—É.</small>
        `;
        document.body.insertBefore(errorDiv, document.querySelector('.controls'));
        
        // Hide controls and tabs on error
        const controls = document.querySelector('.controls');
        const tabs = document.querySelector('.tabs');
        const tabpanels = document.querySelector('.tabpanels');
        if (controls) controls.style.display = 'none';
        if (tabs) tabs.style.display = 'none';
        if (tabpanels) tabpanels.style.display = 'none';
        
        updateEl.textContent = '‚ùå –ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è';
        updateEl.style.color = '#d32f2f';
      }
    }

    // Initialize dashboard components with data
    async function initializeDashboardWithData(json) {
      const rows = json.data;

      // Modal wiring
      const overlay = document.getElementById('dayModalOverlay');
      const openBtn = document.getElementById('openDaySummary');
      const closeBtn = document.getElementById('closeDayModal');
      const doneBtn = document.getElementById('doneDay');
      const dayPicker = document.getElementById('dayPicker');
      const summaryContainer = document.getElementById('daySummaryContainer');
      const exportBtn = document.getElementById('exportDayCsv');

      // Country modal wiring
      const countryOverlay = document.getElementById('countryModalOverlay');
      const closeCountryBtn = document.getElementById('closeCountryModal');
      const doneCountryBtn = document.getElementById('doneCountry');
      function openCountryModal() { 
        countryOverlay.style.display = 'flex'; 
        document.body.style.overflow = 'hidden';
      }
      function closeCountryModal() { 
        countryOverlay.style.display = 'none'; 
        document.body.style.overflow = '';
      }
      closeCountryBtn.addEventListener('click', closeCountryModal);
      doneCountryBtn.addEventListener('click', closeCountryModal);
      countryOverlay.addEventListener('click', (e) => { if (e.target === countryOverlay) closeCountryModal(); });

      // Lead modal wiring
      const leadOverlay = document.getElementById('leadModalOverlay');
      const closeLeadBtn = document.getElementById('closeLeadModal');
      const doneLeadBtn = document.getElementById('doneLead');
      function openLeadModal() { 
        leadOverlay.style.display = 'flex'; 
        document.body.style.overflow = 'hidden';
      }
      function closeLeadModal() { 
        leadOverlay.style.display = 'none'; 
        document.body.style.overflow = '';
      }
      closeLeadBtn.addEventListener('click', closeLeadModal);
      doneLeadBtn.addEventListener('click', closeLeadModal);
      leadOverlay.addEventListener('click', (e) => { if (e.target === leadOverlay) closeLeadModal(); });

      function openModal() { 
        overlay.style.display = 'flex';
        document.body.style.overflow = 'hidden';
      }
      function closeModal() { 
        overlay.style.display = 'none';
        document.body.style.overflow = '';
      }
      openBtn.addEventListener('click', () => {
        dayPicker.value = toIsoDateInputValue(maxDate);
        renderDaySummary(new Date(dayPicker.value));
        // –ø—ñ—Å–ª—è –ø–µ—Ä–≤–∏–Ω–Ω–æ–≥–æ —Ä–µ–Ω–¥–µ—Ä–∞ –æ–¥—Ä–∞–∑—É –≤—ñ–¥—Å–æ—Ä—Ç—É—î–º–æ –∑–∞ –≤–∏–±—Ä–∞–Ω–æ—é –∫–æ–ª–æ–Ω–∫–æ—é
        const sortSelect = document.getElementById('sortColumn');
        if (sortSelect) sortDayData(sortSelect.value || 'Created');
        // –ø—ñ–¥–≤—ñ—Å–∏–º–æ —Å–ª—É—Ö–∞—á—ñ –Ω–∞ –µ–ª–µ–º–µ–Ω—Ç–∏ —Å–æ—Ä—Ç—É–≤–∞–Ω–Ω—è —â–æ—Ä–∞–∑—É –ø—Ä–∏ –≤—ñ–¥–∫—Ä–∏—Ç—Ç—ñ
        const sortBtn = document.getElementById('sortButton');
        if (sortBtn && !sortBtn.__bound) {
          sortBtn.addEventListener('click', () => {
            const col = (document.getElementById('sortColumn') || {}).value || 'Created';
            sortDayData(col);
          });
          sortBtn.__bound = true;
        }
        if (sortSelect && !sortSelect.__bound) {
          sortSelect.addEventListener('change', () => {
            const col = sortSelect.value || 'Created';
            sortDayData(col);
          });
          sortSelect.__bound = true;
        }
        openModal();
      });
      closeBtn.addEventListener('click', closeModal);
      doneBtn.addEventListener('click', closeModal);
      overlay.addEventListener('click', (e) => { if (e.target === overlay) closeModal(); });
      dayPicker.addEventListener('change', () => {
        const d = new Date(dayPicker.value);
        renderDaySummary(d);
        // –ø—ñ—Å–ª—è –∑–º—ñ–Ω–∏ –¥–∞—Ç–∏ ‚Äî –æ–¥—Ä–∞–∑—É –∑–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ –æ—Å—Ç–∞–Ω–Ω—ñ–π –≤–∏–±—ñ—Ä —Å–æ—Ä—Ç—É–≤–∞–Ω–Ω—è
        const sortSelect = document.getElementById('sortColumn');
        if (sortSelect) sortDayData(sortSelect.value || 'Created');
      });

      exportBtn.addEventListener('click', () => {
        const d = new Date(dayPicker.value);
        const dataForDay = getRowsForDay(d);
        const csv = buildCsvForDay(dataForDay);
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `day-summary-${toIsoDateInputValue(d)}.csv`;
        a.click();
        URL.revokeObjectURL(url);
      });

      // use shared chartRefs/lastFilteredRows declared above

      // All aggregation functions are now imported from './aggregates.js'

      // Helper function to get or cache DOM element
      function getChartElement(id) {
        if (!chartElements[id]) {
          chartElements[id] = document.getElementById(id);
        }
        return chartElements[id];
      }

      // Helper function to render or update chart
      function renderOrUpdateChart(chartRef, elementId, renderFn, updateFn, ...args) {
        const element = getChartElement(elementId);
        if (!element) {
          console.warn(`Chart element not found: ${elementId}`);
          return null;
        }

        if (chartRef && chartRef.data) {
          // Chart exists, try to update
          if (updateFn && updateFn(chartRef, ...args)) {
            return chartRef; // Successfully updated
          } else {
            // Update failed, destroy and recreate
            destroyIfExists(chartRef);
          }
        }
        
        // Create new chart
        return renderFn(element, ...args);
      }

      // Render Funnel charts (tab-funnel)
      function renderFunnelCharts(filteredRows) {
        if (shouldRecalculateAggregations(filteredRows, aggregationCache) || !aggregationCache.funnel) {
          const agg = buildAggregates(filteredRows);
          aggregationCache.funnel = agg;
          updateAggregationCache(aggregationCache, filteredRows, { funnel: agg });
        }
        const agg = aggregationCache.funnel;

        scheduleChartUpdate(() => {
          chartRefs.createdFound = renderOrUpdateChart(
            chartRefs.createdFound,
            'chartCreatedToFound',
            renderPairedBarChart,
            updatePairedBarChart,
            agg.dates, 'Created', agg.created, 'Sent Requests', agg.sent
          );
          
          chartRefs.sentConnected = renderOrUpdateChart(
            chartRefs.sentConnected,
            'chartSentToConnected',
            renderPairedBarChart,
            updatePairedBarChart,
            agg.dates, 'Sent Requests', agg.sent, 'Connected', agg.connected
          );
          
          chartRefs.connectedReplies = renderOrUpdateChart(
            chartRefs.connectedReplies,
            'chartConnectedToReplies',
            renderPairedBarChart,
            updatePairedBarChart,
            agg.dates, 'Connected', agg.connected, 'Replies', agg.replies
          );
          
          chartRefs.repliesPositive = renderOrUpdateChart(
            chartRefs.repliesPositive,
            'chartRepliesToPositive',
            renderPairedBarChart,
            updatePairedBarChart,
            agg.dates, 'Replies', agg.replies, 'Positive Replies', agg.positive
          );
          
          chartRefs.positiveEvents = renderOrUpdateChart(
            chartRefs.positiveEvents,
            'chartPositiveToEvents',
            renderPairedBarChart,
            updatePairedBarChart,
            agg.dates, 'Positive Replies', agg.positive, 'Events', agg.events
          );
        });
      }

      // Render Country charts (tab-country)
      function renderCountryCharts(filteredRows) {
        if (shouldRecalculateAggregations(filteredRows, aggregationCache) || !aggregationCache.country) {
          const countryAgg = buildCountryAggregates(filteredRows);
          aggregationCache.country = countryAgg;
          updateAggregationCache(aggregationCache, filteredRows, { country: countryAgg });
        }
        const countryAgg = aggregationCache.country;

        scheduleChartUpdate(() => {
          chartRefs.countryConversionRate = renderOrUpdateChart(
            chartRefs.countryConversionRate,
            'chartCountryConversionRate',
            (el, labels, label, data, color) => {
              const chart = renderConversionRateChart(el, labels, label, data, color);
              if (chart) {
                chart.options.onClick = (evt, activeEls) => {
                  const points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
                  if (points && points.length) {
                    const idx = points[0].index;
                    const country = labels[idx];
                    openCountryInsight(country, filteredRows);
                  }
                };
              }
              return chart;
            },
            null,
            countryAgg.countries, 'Conversion Rate (%)', countryAgg.conversionRates, 'rgba(75,192,192,0.6)'
          );

          chartRefs.countryCreatedFound = renderOrUpdateChart(
            chartRefs.countryCreatedFound,
            'chartCountryCreatedToFound',
            (el, labels, leftLabel, leftData, rightLabel, rightData) => {
              const chart = renderPairedBarChart(el, labels, leftLabel, leftData, rightLabel, rightData);
              if (chart) {
                chart.options.onClick = (evt, activeEls) => {
                  const points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
                  if (points && points.length) {
                    const idx = points[0].index;
                    const country = labels[idx];
                    openCountryInsight(country, filteredRows);
                  }
                };
              }
              return chart;
            },
            updatePairedBarChart,
            countryAgg.countries, 'Created', countryAgg.created, 'Sent Requests', countryAgg.sent
          );

          chartRefs.countrySentConnected = renderOrUpdateChart(
            chartRefs.countrySentConnected,
            'chartCountrySentToConnected',
            (el, labels, leftLabel, leftData, rightLabel, rightData) => {
              const chart = renderPairedBarChart(el, labels, leftLabel, leftData, rightLabel, rightData);
              if (chart) {
                chart.options.onClick = (evt, activeEls) => {
                  const points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
                  if (points && points.length) {
                    const idx = points[0].index;
                    const country = labels[idx];
                    openCountryInsight(country, filteredRows);
                  }
                };
              }
              return chart;
            },
            updatePairedBarChart,
            countryAgg.countries, 'Sent Requests', countryAgg.sent, 'Connected', countryAgg.connected
          );

          chartRefs.countryConnectedReplies = renderOrUpdateChart(
            chartRefs.countryConnectedReplies,
            'chartCountryConnectedToReplies',
            (el, labels, leftLabel, leftData, rightLabel, rightData) => {
              const chart = renderPairedBarChart(el, labels, leftLabel, leftData, rightLabel, rightData);
              if (chart) {
                chart.options.onClick = (evt, activeEls) => {
                  const points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
                  if (points && points.length) {
                    const idx = points[0].index;
                    const country = labels[idx];
                    openCountryInsight(country, filteredRows);
                  }
                };
              }
              return chart;
            },
            updatePairedBarChart,
            countryAgg.countries, 'Connected', countryAgg.connected, 'Replies', countryAgg.replies
          );

          chartRefs.countryRepliesPositive = renderOrUpdateChart(
            chartRefs.countryRepliesPositive,
            'chartCountryRepliesToPositive',
            (el, labels, leftLabel, leftData, rightLabel, rightData) => {
              const chart = renderPairedBarChart(el, labels, leftLabel, leftData, rightLabel, rightData);
              if (chart) {
                chart.options.onClick = (evt, activeEls) => {
                  const points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
                  if (points && points.length) {
                    const idx = points[0].index;
                    const country = labels[idx];
                    openCountryInsight(country, filteredRows);
                  }
                };
              }
              return chart;
            },
            updatePairedBarChart,
            countryAgg.countries, 'Replies', countryAgg.replies, 'Positive Replies', countryAgg.positive
          );

          chartRefs.countryPositiveEvents = renderOrUpdateChart(
            chartRefs.countryPositiveEvents,
            'chartCountryPositiveToEvents',
            (el, labels, leftLabel, leftData, rightLabel, rightData) => {
              const chart = renderPairedBarChart(el, labels, leftLabel, leftData, rightLabel, rightData);
              if (chart) {
                chart.options.onClick = (evt, activeEls) => {
                  const points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
                  if (points && points.length) {
                    const idx = points[0].index;
                    const country = labels[idx];
                    openCountryInsight(country, filteredRows);
                  }
                };
              }
              return chart;
            },
            updatePairedBarChart,
            countryAgg.countries, 'Positive Replies', countryAgg.positive, 'Events', countryAgg.events
          );
        });
      }

      // Render Weekly charts (tab-weekly)
      function renderWeeklyCharts(filteredRows) {
        if (shouldRecalculateAggregations(filteredRows, aggregationCache) || !aggregationCache.weekly) {
          const weekAgg = buildWeeklyAggregates(filteredRows);
          aggregationCache.weekly = weekAgg;
          updateAggregationCache(aggregationCache, filteredRows, { weekly: weekAgg });
        }
        const weekAgg = aggregationCache.weekly;

        scheduleChartUpdate(() => {
          chartRefs.weekCreatedFound = renderOrUpdateChart(
            chartRefs.weekCreatedFound, 'chartWeekCreatedToFound', renderPairedBarChart, updatePairedBarChart,
            weekAgg.weeks, 'Created', weekAgg.created, 'Sent Requests', weekAgg.sent
          );
          chartRefs.weekSentConnected = renderOrUpdateChart(
            chartRefs.weekSentConnected, 'chartWeekSentToConnected', renderPairedBarChart, updatePairedBarChart,
            weekAgg.weeks, 'Sent Requests', weekAgg.sent, 'Connected', weekAgg.connected
          );
          chartRefs.weekConnectedReplies = renderOrUpdateChart(
            chartRefs.weekConnectedReplies, 'chartWeekConnectedToReplies', renderPairedBarChart, updatePairedBarChart,
            weekAgg.weeks, 'Connected', weekAgg.connected, 'Replies', weekAgg.replies
          );
          chartRefs.weekRepliesPositive = renderOrUpdateChart(
            chartRefs.weekRepliesPositive, 'chartWeekRepliesToPositive', renderPairedBarChart, updatePairedBarChart,
            weekAgg.weeks, 'Replies', weekAgg.replies, 'Positive Replies', weekAgg.positive
          );
          chartRefs.weekPositiveEvents = renderOrUpdateChart(
            chartRefs.weekPositiveEvents, 'chartWeekPositiveToEvents', renderPairedBarChart, updatePairedBarChart,
            weekAgg.weeks, 'Positive Replies', weekAgg.positive, 'Events', weekAgg.events
          );
        });
      }

      // Render Monthly charts (tab-monthly)
      function renderMonthlyCharts(filteredRows) {
        if (shouldRecalculateAggregations(filteredRows, aggregationCache) || !aggregationCache.monthly) {
          const monthAgg = buildMonthlyAggregates(filteredRows);
          aggregationCache.monthly = monthAgg;
          updateAggregationCache(aggregationCache, filteredRows, { monthly: monthAgg });
        }
        const monthAgg = aggregationCache.monthly;

        scheduleChartUpdate(() => {
          chartRefs.monthConversionRate = renderOrUpdateChart(
            chartRefs.monthConversionRate, 'chartMonthConversionRate', renderConversionRateChart, null,
            monthAgg.months, 'Conversion Rate (%)', monthAgg.conversionRates, 'rgba(75,192,192,0.6)'
          );
          chartRefs.monthCreatedFound = renderOrUpdateChart(
            chartRefs.monthCreatedFound, 'chartMonthCreatedToFound', renderPairedBarChart, updatePairedBarChart,
            monthAgg.months, 'Created', monthAgg.created, 'Sent Requests', monthAgg.sent
          );
          chartRefs.monthSentConnected = renderOrUpdateChart(
            chartRefs.monthSentConnected, 'chartMonthSentToConnected', renderPairedBarChart, updatePairedBarChart,
            monthAgg.months, 'Sent Requests', monthAgg.sent, 'Connected', monthAgg.connected
          );
          chartRefs.monthConnectedReplies = renderOrUpdateChart(
            chartRefs.monthConnectedReplies, 'chartMonthConnectedToReplies', renderPairedBarChart, updatePairedBarChart,
            monthAgg.months, 'Connected', monthAgg.connected, 'Replies', monthAgg.replies
          );
          chartRefs.monthRepliesPositive = renderOrUpdateChart(
            chartRefs.monthRepliesPositive, 'chartMonthRepliesToPositive', renderPairedBarChart, updatePairedBarChart,
            monthAgg.months, 'Replies', monthAgg.replies, 'Positive Replies', monthAgg.positive
          );
          chartRefs.monthPositiveEvents = renderOrUpdateChart(
            chartRefs.monthPositiveEvents, 'chartMonthPositiveToEvents', renderPairedBarChart, updatePairedBarChart,
            monthAgg.months, 'Positive Replies', monthAgg.positive, 'Events', monthAgg.events
          );
        });
      }

      // Render Leaderboard charts (tab-leaderboard)
      function renderLeaderboardCharts(filteredRows) {
        if (shouldRecalculateAggregations(filteredRows, aggregationCache) || !aggregationCache.leaderboard) {
          const lbAgg = buildLeaderboardAggregates(filteredRows);
          aggregationCache.leaderboard = lbAgg;
          updateAggregationCache(aggregationCache, filteredRows, { leaderboard: lbAgg });
        }
        const lbAgg = aggregationCache.leaderboard;

        scheduleChartUpdate(() => {
          chartRefs.lbConversionRate = renderOrUpdateChart(
            chartRefs.lbConversionRate,
            'chartLbConversionRate',
            (el, labels, label, data, color) => {
              const chart = renderConversionRateChart(el, labels, label, data, color);
              if (chart) {
                chart.options.onClick = (evt, activeEls) => {
                  const points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
                  if (points && points.length) {
                    const idx = points[0].index;
                    const name = labels[idx];
                    openLeadInsight(name, filteredRows);
                  }
                };
              }
              return chart;
            },
            null,
            lbAgg.names, 'Conversion Rate (%)', lbAgg.conversionRates, 'rgba(75,192,192,0.6)'
          );

          chartRefs.lbCreated = renderOrUpdateChart(
            chartRefs.lbCreated,
            'chartLbCreated',
            (el, labels, label, data, color) => {
              const chart = renderSingleBarChart(el, labels, label, data, color);
              if (chart) {
                chart.options.onClick = (evt, activeEls) => {
                  const points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
                  if (points && points.length) {
                    const idx = points[0].index;
                    const name = labels[idx];
                    openLeadInsight(name, filteredRows);
                  }
                };
              }
              return chart;
            },
            updateSingleBarChart,
            lbAgg.names, 'Created', lbAgg.created, 'rgba(54,162,235,0.6)'
          );

          chartRefs.lbSent = renderOrUpdateChart(
            chartRefs.lbSent,
            'chartLbSent',
            (el, labels, label, data, color) => {
              const chart = renderSingleBarChart(el, labels, label, data, color);
              if (chart) {
                chart.options.onClick = (evt, activeEls) => {
                  const points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
                  if (points && points.length) {
                    const idx = points[0].index;
                    const name = labels[idx];
                    openLeadInsight(name, filteredRows);
                  }
                };
              }
              return chart;
            },
            updateSingleBarChart,
            lbAgg.names, 'Sent Requests', lbAgg.sent, 'rgba(153,102,255,0.6)'
          );

          chartRefs.lbPositive = renderOrUpdateChart(
            chartRefs.lbPositive,
            'chartLbPositive',
            (el, labels, label, data, color) => {
              const chart = renderSingleBarChart(el, labels, label, data, color);
              if (chart) {
                chart.options.onClick = (evt, activeEls) => {
                  const points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
                  if (points && points.length) {
                    const idx = points[0].index;
                    const name = labels[idx];
                    openLeadInsight(name, filteredRows);
                  }
                };
              }
              return chart;
            },
            updateSingleBarChart,
            lbAgg.names, 'Positive Replies', lbAgg.positive, 'rgba(75,192,192,0.6)'
          );

          chartRefs.lbEvents = renderOrUpdateChart(
            chartRefs.lbEvents,
            'chartLbEvents',
            (el, labels, label, data, color) => {
              const chart = renderSingleBarChart(el, labels, label, data, color);
              if (chart) {
                chart.options.onClick = (evt, activeEls) => {
                  const points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
                  if (points && points.length) {
                    const idx = points[0].index;
                    const name = labels[idx];
                    openLeadInsight(name, filteredRows);
                  }
                };
              }
              return chart;
            },
            updateSingleBarChart,
            lbAgg.names, 'Events Created', lbAgg.events, 'rgba(255,206,86,0.6)'
          );
        });
      }

      // Render Source charts (tab-source)
      function renderSourceCharts(filteredRows) {
        if (shouldRecalculateAggregations(filteredRows, aggregationCache) || !aggregationCache.source) {
          const sourceAgg = buildSourceAggregates(filteredRows);
          aggregationCache.source = sourceAgg;
          updateAggregationCache(aggregationCache, filteredRows, { source: sourceAgg });
        }
        const sourceAgg = aggregationCache.source;

        scheduleChartUpdate(() => {
          chartRefs.sourceConversionRate = renderOrUpdateChart(
            chartRefs.sourceConversionRate, 'chartSourceConversionRate', renderConversionRateChart, null,
            sourceAgg.sources, 'Conversion Rate (%)', sourceAgg.conversionRates, 'rgba(75,192,192,0.6)'
          );
          chartRefs.sourceCreatedToSent = renderOrUpdateChart(
            chartRefs.sourceCreatedToSent, 'chartSourceCreatedToSent', renderPairedBarChart, updatePairedBarChart,
            sourceAgg.sources, 'Created', sourceAgg.created, 'Sent Requests', sourceAgg.sentRequests
          );
          chartRefs.sourceSentToConnected = renderOrUpdateChart(
            chartRefs.sourceSentToConnected, 'chartSourceSentToConnected', renderPairedBarChart, updatePairedBarChart,
            sourceAgg.sources, 'Sent Requests', sourceAgg.sentRequests, 'Connected', sourceAgg.connected
          );
          chartRefs.sourceConnectedToReplies = renderOrUpdateChart(
            chartRefs.sourceConnectedToReplies, 'chartSourceConnectedToReplies', renderPairedBarChart, updatePairedBarChart,
            sourceAgg.sources, 'Connected', sourceAgg.connected, 'Total Replies', sourceAgg.totalReplies
          );
          chartRefs.sourceRepliesToPositive = renderOrUpdateChart(
            chartRefs.sourceRepliesToPositive, 'chartSourceRepliesToPositive', renderPairedBarChart, updatePairedBarChart,
            sourceAgg.sources, 'Total Replies', sourceAgg.totalReplies, 'Positive Replies', sourceAgg.positiveReplies
          );
          chartRefs.sourcePositiveToEvents = renderOrUpdateChart(
            chartRefs.sourcePositiveToEvents, 'chartSourcePositiveToEvents', renderPairedBarChart, updatePairedBarChart,
            sourceAgg.sources, 'Positive Replies', sourceAgg.positiveReplies, 'Events', sourceAgg.events
          );
        });
      }

      // Main render function - now with lazy loading
      function renderAll(filteredRows) {
        lastFilteredRows = filteredRows;
        
        // Only render charts for active tab
        const activeTab = document.querySelector('.tabpanel.active')?.id;
        
        if (activeTab === 'tab-funnel' || !activeTab) {
          renderFunnelCharts(filteredRows);
          renderedTabs.funnel = true;
        }
        if (activeTab === 'tab-country') {
          renderCountryCharts(filteredRows);
          renderedTabs.country = true;
        }
        if (activeTab === 'tab-weekly') {
          renderWeeklyCharts(filteredRows);
          renderedTabs.weekly = true;
        }
        if (activeTab === 'tab-monthly') {
          renderMonthlyCharts(filteredRows);
          renderedTabs.monthly = true;
        }
        if (activeTab === 'tab-leaderboard') {
          renderLeaderboardCharts(filteredRows);
          renderedTabs.leaderboard = true;
        }
        if (activeTab === 'tab-source') {
          renderSourceCharts(filteredRows);
          renderedTabs.source = true;
        }
      }

      // expose re-render for tabs logic
      rerenderAll = renderAll;
      // also attach to window for safety
      window._rerenderAll = renderAll;

      function applyCurrentFilter() {
        const from = new Date(document.getElementById('fromDate').value);
        const to = new Date(document.getElementById('toDate').value);
        // normalize times
        from.setHours(0,0,0,0);
        to.setHours(23,59,59,999);
        const filtered = rows.filter(r => {
          const d = parseDdMmYyyyToDate(r.Date);
          return d && d >= from && d <= to;
        });
        renderAll(filtered);
      }

      document.getElementById('applyFilter').addEventListener('click', applyCurrentFilter);
      document.getElementById('resetFilter').addEventListener('click', () => {
        const fromEl = document.getElementById('fromDate');
        const toEl = document.getElementById('toDate');
        const datesList = rows
          .map(r => parseDdMmYyyyToDate(r.Date))
          .filter(Boolean)
          .sort((a,b) => a - b);
        const minDate = datesList[0] || new Date();
        const maxDate = datesList[datesList.length - 1] || new Date();
        if (fromEl && toEl) {
          fromEl.value = toIsoDateInputValue(minDate);
          toEl.value = toIsoDateInputValue(maxDate);
        }
        renderAll(rows);
      });

      // initial render
      renderAll(rows);

      function getRowsForDay(dateObj) {
        const target = toIsoDateInputValue(dateObj); // YYYY-MM-DD
        return rows.filter(r => {
          const d = parseDdMmYyyyToDate(r.Date);
          if (!d) return false;
          return toIsoDateInputValue(d) === target;
        });
      }

      function sortDayData(sortColumn) {
        if (!currentDayData) return;
        
        const sortedNames = Object.keys(currentDayData).sort((a, b) => {
          const valueA = currentDayData[a][sortColumn] || 0;
          const valueB = currentDayData[b][sortColumn] || 0;
          return valueB - valueA; // –≤—ñ–¥ –±—ñ–ª—å—à–æ–≥–æ –¥–æ –º–µ–Ω—à–æ–≥–æ
        });
        
        const totals = { Created: 0, SentRequests: 0, Connected: 0, PositiveReplies: 0, Events: 0 };
        let html = '';
        html += '<table class="summary-table">';
        html += '<thead><tr><th>Name</th><th>Created</th><th>Sent Requests</th><th>Connected</th><th>Positive Replies</th><th>Events</th></tr></thead>';
        html += '<tbody>';
        
        for (const n of sortedNames) {
          const row = currentDayData[n];
          totals.Created += row.Created;
          totals.SentRequests += row.SentRequests;
          totals.Connected += row.Connected;
          totals.PositiveReplies += row.PositiveReplies;
          totals.Events += row.Events;
          html += `<tr><td>${n}</td><td>${row.Created}</td><td>${row.SentRequests}</td><td>${row.Connected}</td><td>${row.PositiveReplies}</td><td>${row.Events}</td></tr>`;
        }
        
        html += '</tbody>';
        html += `<tfoot><tr><td>Total</td><td>${totals.Created}</td><td>${totals.SentRequests}</td><td>${totals.Connected}</td><td>${totals.PositiveReplies}</td><td>${totals.Events}</td></tr></tfoot>`;
        html += '</table>';
        
        document.getElementById('daySummaryContainer').innerHTML = html;
      }

      function renderDaySummary(dateObj) {
        const dayRows = getRowsForDay(dateObj);
        // aggregate by Name for the selected day
        const byName = {};
        for (const r of dayRows) {
          const name = r.Name || 'Unknown';
          if (!byName[name]) {
            byName[name] = {
              Created: 0,
              SentRequests: 0,
              Connected: 0,
              PositiveReplies: 0,
              Events: 0
            };
          }
          byName[name].Created += Number(r["Created"] || 0);
          byName[name].SentRequests += Number(r["Sent Requests"] || 0);
          byName[name].Connected += Number(r["Connected"] || 0);
          byName[name].PositiveReplies += Number(r["Positive Replies"] || 0);
          byName[name].Events += Number(r["Events Created"] || 0);
        }

        // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –¥–∞–Ω—ñ –¥–ª—è —Å–æ—Ä—Ç—É–≤–∞–Ω–Ω—è —ñ –æ–¥—Ä–∞–∑—É —Ä–µ–Ω–¥–µ—Ä–∏–º–æ –∑–∞ –ø–æ—Ç–æ—á–Ω–∏–º –≤–∏–±–æ—Ä–æ–º
        currentDayData = byName;
        const sortSelect = document.getElementById('sortColumn');
        const selected = sortSelect ? sortSelect.value : 'Created';
        sortDayData(selected);
        document.getElementById('dayModalTitle').textContent = `Day Summary ‚Äî ${toIsoDateInputValue(dateObj)}`;
      }

      function buildCsvForDay(dayRows) {
        const headers = ["Name","Created","Sent Requests","Connected","Positive Replies","Events"];
        const byName = {};
        for (const r of dayRows) {
          const name = r.Name || 'Unknown';
          if (!byName[name]) {
            byName[name] = { Created: 0, SentRequests: 0, Connected: 0, PositiveReplies: 0, Events: 0 };
          }
          byName[name].Created += Number(r["Created"] || 0);
          byName[name].SentRequests += Number(r["Sent Requests"] || 0);
          byName[name].Connected += Number(r["Connected"] || 0);
          byName[name].PositiveReplies += Number(r["Positive Replies"] || 0);
          byName[name].Events += Number(r["Events Created"] || 0);
        }
        let csv = headers.join(',') + '\n';
        for (const name of Object.keys(byName)) {
          const r = byName[name];
          csv += `${name},${r.Created},${r.SentRequests},${r.Connected},${r.PositiveReplies},${r.Events}\n`;
        }
        return csv;
      }
    }

    // Tabs logic
    function initTabs() {
      const tabs = [
        { btn: document.getElementById('tab-funnel-btn'), panel: document.getElementById('tab-funnel') },
        { btn: document.getElementById('tab-country-btn'), panel: document.getElementById('tab-country') },
        { btn: document.getElementById('tab-weekly-btn'), panel: document.getElementById('tab-weekly') },
        { btn: document.getElementById('tab-monthly-btn'), panel: document.getElementById('tab-monthly') },
        { btn: document.getElementById('tab-leaderboard-btn'), panel: document.getElementById('tab-leaderboard') },
        { btn: document.getElementById('tab-source-btn'), panel: document.getElementById('tab-source') }
      ];

      // Debounced resize function for better performance
      const debouncedResizeCharts = debounce((panelId) => {
        scheduleChartUpdate(() => {
          if (panelId === 'tab-funnel') {
            [chartRefs.createdFound, chartRefs.sentConnected, chartRefs.connectedReplies, chartRefs.repliesPositive, chartRefs.positiveEvents]
              .forEach(c => c && typeof c.resize === 'function' && c.resize());
          } else if (panelId === 'tab-country') {
            [
              chartRefs.countryConversionRate,
              chartRefs.countryCreatedFound,
              chartRefs.countrySentConnected,
              chartRefs.countryConnectedReplies,
              chartRefs.countryRepliesPositive,
              chartRefs.countryPositiveEvents
            ].forEach(c => c && typeof c.resize === 'function' && c.resize());
          } else if (panelId === 'tab-weekly') {
            [chartRefs.weekCreatedFound, chartRefs.weekSentConnected, chartRefs.weekConnectedReplies, chartRefs.weekRepliesPositive, chartRefs.weekPositiveEvents]
              .forEach(c => c && typeof c.resize === 'function' && c.resize());
          } else if (panelId === 'tab-monthly') {
            [chartRefs.monthConversionRate, chartRefs.monthCreatedFound, chartRefs.monthSentConnected, chartRefs.monthConnectedReplies, chartRefs.monthRepliesPositive, chartRefs.monthPositiveEvents]
              .forEach(c => c && typeof c.resize === 'function' && c.resize());
          } else if (panelId === 'tab-leaderboard') {
            [chartRefs.lbConversionRate, chartRefs.lbCreated, chartRefs.lbSent, chartRefs.lbPositive, chartRefs.lbEvents]
              .forEach(c => c && typeof c.resize === 'function' && c.resize());
          } else if (panelId === 'tab-source') {
            [chartRefs.sourceConversionRate, chartRefs.sourceCreatedToSent, chartRefs.sourceSentToConnected, chartRefs.sourceConnectedToReplies, chartRefs.sourceRepliesToPositive, chartRefs.sourcePositiveToEvents]
              .forEach(c => c && typeof c.resize === 'function' && c.resize());
          }
        });
      }, 200);

      function resizeChartsFor(panelId) {
        debouncedResizeCharts(panelId);
      }

      function activate(targetBtn) {
        const currentActivePanel = tabs.find(({panel}) => panel.classList.contains('active'))?.panel;
        const newPanel = tabs.find(({btn}) => btn === targetBtn)?.panel;
        const panelId = targetBtn.getAttribute('aria-controls');
        
        if (currentActivePanel === newPanel) return;
        
        // –û–Ω–æ–≤–ª—é—î–º–æ –∫–Ω–æ–ø–∫–∏
        tabs.forEach(({btn}) => {
          const active = btn === targetBtn;
          btn.classList.toggle('active', active);
          btn.setAttribute('aria-selected', active ? 'true' : 'false');
        });
        
        // Render charts for new tab if not already rendered
        if (newPanel && lastFilteredRows.length > 0) {
          const tabKey = panelId.replace('tab-', '');
          if (!renderedTabs[tabKey]) {
            // Render charts for this tab
            if (panelId === 'tab-funnel') {
              renderFunnelCharts(lastFilteredRows);
            } else if (panelId === 'tab-country') {
              renderCountryCharts(lastFilteredRows);
            } else if (panelId === 'tab-weekly') {
              renderWeeklyCharts(lastFilteredRows);
            } else if (panelId === 'tab-monthly') {
              renderMonthlyCharts(lastFilteredRows);
            } else if (panelId === 'tab-leaderboard') {
              renderLeaderboardCharts(lastFilteredRows);
            } else if (panelId === 'tab-source') {
              renderSourceCharts(lastFilteredRows);
            }
            renderedTabs[tabKey] = true;
          }
        }
        
        // –Ø–∫—â–æ —î –ø–æ–ø–µ—Ä–µ–¥–Ω—è –ø–∞–Ω–µ–ª—å - –∞–Ω—ñ–º—É—î–º–æ fade out
        if (currentActivePanel) {
          // –ü–æ—á–∏–Ω–∞—î–º–æ fade out –∞–Ω—ñ–º–∞—Ü—ñ—é
          currentActivePanel.style.opacity = '0';
          currentActivePanel.style.transform = 'translateY(20px)';
          
          // –ü—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è fade out –ø—Ä–∏—Ö–æ–≤—É—î–º–æ –ø–∞–Ω–µ–ª—å
          setTimeout(() => {
            currentActivePanel.classList.remove('active');
            
            // –ü–æ–∫–∞–∑—É—î–º–æ –Ω–æ–≤—É –ø–∞–Ω–µ–ª—å
            if (newPanel) {
              // –°–ø–æ—á–∞—Ç–∫—É –≤—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ display: block (–±–µ–∑ –∞–Ω—ñ–º–∞—Ü—ñ—ó)
              newPanel.style.display = 'block';
              newPanel.style.opacity = '0';
              newPanel.style.transform = 'translateY(20px)';
              newPanel.classList.add('active');
              
              // –î–∞—î–º–æ –±—Ä–∞—É–∑–µ—Ä—É —á–∞—Å –Ω–∞ —Ä–µ–Ω–¥–µ—Ä –ø–µ—Ä–µ–¥ –∞–Ω—ñ–º–∞—Ü—ñ—î—é
              requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                  // –ü–æ—á–∏–Ω–∞—î–º–æ fade in –∞–Ω—ñ–º–∞—Ü—ñ—é
                  newPanel.style.opacity = '1';
                  newPanel.style.transform = 'translateY(0)';
                  
                  // –û—á–∏—â–∞—î–º–æ inline styles –ø—ñ—Å–ª—è –∞–Ω—ñ–º–∞—Ü—ñ—ó
                  setTimeout(() => {
                    newPanel.style.opacity = '';
                    newPanel.style.transform = '';
                    newPanel.style.display = '';
                    
                    // Resize charts –ø—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –∞–Ω—ñ–º–∞—Ü—ñ—ó
                    resizeChartsFor(panelId);
                  }, 300);
                });
              });
            }
          }, 300); // –ß–µ–∫–∞—î–º–æ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è fade out
        } else {
          // –ù–µ–º–∞—î –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ—ó –ø–∞–Ω–µ–ª—ñ - –ø—Ä–æ—Å—Ç–æ –ø–æ–∫–∞–∑—É—î–º–æ –Ω–æ–≤—É –∑ –∞–Ω—ñ–º–∞—Ü—ñ—î—é
          if (newPanel) {
            // –°–ø–æ—á–∞—Ç–∫—É –≤—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ display: block (–±–µ–∑ –∞–Ω—ñ–º–∞—Ü—ñ—ó)
            newPanel.style.display = 'block';
            newPanel.style.opacity = '0';
            newPanel.style.transform = 'translateY(20px)';
            newPanel.classList.add('active');
            
            // –î–∞—î–º–æ –±—Ä–∞—É–∑–µ—Ä—É —á–∞—Å –Ω–∞ —Ä–µ–Ω–¥–µ—Ä –ø–µ—Ä–µ–¥ –∞–Ω—ñ–º–∞—Ü—ñ—î—é
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                // –ü–æ—á–∏–Ω–∞—î–º–æ fade in –∞–Ω—ñ–º–∞—Ü—ñ—é
                newPanel.style.opacity = '1';
                newPanel.style.transform = 'translateY(0)';
                
                // –û—á–∏—â–∞—î–º–æ inline styles –ø—ñ—Å–ª—è –∞–Ω—ñ–º–∞—Ü—ñ—ó
                setTimeout(() => {
                  newPanel.style.opacity = '';
                  newPanel.style.transform = '';
                  newPanel.style.display = '';
                  
                  // Resize charts –ø—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –∞–Ω—ñ–º–∞—Ü—ñ—ó
                  resizeChartsFor(panelId);
                }, 300);
              });
            });
          }
        }
        
        // –ü—Ä–∏—Ö–æ–≤—É—î–º–æ –≤—Å—ñ —ñ–Ω—à—ñ –ø–∞–Ω–µ–ª—ñ (–Ω–µ –ø–æ—Ç–æ—á–Ω—É —Ç–∞ –Ω–µ –Ω–æ–≤—É)
        tabs.forEach(({panel}) => {
          if (panel !== currentActivePanel && panel !== newPanel) {
            panel.classList.remove('active');
          }
        });
      }
      tabs.forEach(({btn}) => btn.addEventListener('click', () => activate(btn)));
    }

    // –î–æ–¥–∞—î–º–æ listener –Ω–∞ –∫–Ω–æ–ø–∫—É —Å–æ—Ä—Ç—É –ø—ñ—Å–ª—è –≤—ñ–¥–∫—Ä–∏—Ç—Ç—è –º–æ–¥–∞–ª–∫–∏ (—â–æ–± –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–æ –±—É–ª–∞ –≤ DOM)
    (function attachSortListenerOnce() {
      const btn = document.getElementById('sortButton');
      if (!btn) return;
      if (!btn.__hasListener) {
        btn.addEventListener('click', () => {
          const sortColumn = (document.getElementById('sortColumn') || {}).value || 'Created';
          if (typeof sortDayData === 'function') sortDayData(sortColumn);
        });
        btn.__hasListener = true;
      }
    })();

    initTabs();
    initDashboard();

    // ===== Country Insight helpers =====
    function aggregateCountrySummary(countryName, rows, fromDate, toDate) {
      const acc = { Created: 0, SentRequests: 0, Connected: 0, Replies: 0, PositiveReplies: 0, Events: 0 };
      for (const r of rows) {
        if ((r.Country || 'Unknown') !== countryName) continue;
        const d = parseDdMmYyyyToDate(r.Date);
        if (!d) continue;
        if (fromDate && d < fromDate) continue;
        if (toDate && d > toDate) continue;
        acc.Created += Number(r['Created'] || 0);
        acc.SentRequests += Number(r['Sent Requests'] || 0);
        acc.Connected += Number(r['Connected'] || 0);
        acc.Replies += Number(r['Total replies'] || 0);
        acc.PositiveReplies += Number(r['Positive Replies'] || 0);
        acc.Events += Number(r['Events Created'] || 0);
      }
      return acc;
    }

    function aggregateCountryMonthly(countryName, rows, fromDate, toDate) {
      const byMonth = {};
      for (const r of rows) {
        if ((r.Country || 'Unknown') !== countryName) continue;
        const d = parseDdMmYyyyToDate(r.Date);
        if (!d) continue;
        if (fromDate && d < fromDate) continue;
        if (toDate && d > toDate) continue;
        const key = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`;
        if (!byMonth[key]) byMonth[key] = { Created: 0, Events: 0 };
        byMonth[key].Created += Number(r['Created'] || 0);
        byMonth[key].Events += Number(r['Events Created'] || 0);
      }
      const months = Object.keys(byMonth).sort();
      return { months, created: months.map(m => byMonth[m].Created), events: months.map(m => byMonth[m].Events) };
    }

    function aggregateCountryTopGenerators(countryName, rows, fromDate, toDate, limit = 5) {
      const byName = {};
      for (const r of rows) {
        if ((r.Country || 'Unknown') !== countryName) continue;
        const d = parseDdMmYyyyToDate(r.Date);
        if (!d) continue;
        if (fromDate && d < fromDate) continue;
        if (toDate && d > toDate) continue;
        const name = r.Name || 'Unknown';
        if (!byName[name]) byName[name] = { Created: 0, Events: 0 };
        byName[name].Created += Number(r['Created'] || 0);
        byName[name].Events += Number(r['Events Created'] || 0);
      }
      const entries = Object.entries(byName).map(([name, v]) => ({ name, ...v, cr: v.Created > 0 ? (v.Events / v.Created) * 100 : 0 }));
      entries.sort((a,b) => b.cr - a.cr || b.Events - a.Events);
      return entries.slice(0, limit);
    }

    function openCountryInsight(countryName, rows) {
      // derive current filter range from inputs
      const from = new Date(document.getElementById('fromDate').value);
      const to = new Date(document.getElementById('toDate').value);
      from.setHours(0,0,0,0);
      to.setHours(23,59,59,999);

      // summary
      const sum = aggregateCountrySummary(countryName, rows, from, to);
      const cr = sum.Created > 0 ? (sum.Events / sum.Created) * 100 : 0;
      const sentToConn = sum.SentRequests > 0 ? (sum.Connected / sum.SentRequests) * 100 : 0;
      const posToRep = sum.Replies > 0 ? (sum.PositiveReplies / sum.Replies) * 100 : 0;
      const summaryHtml = `
        <div class="summary-table-wrapper">
          <table class="summary-table">
            <thead><tr><th>Metric</th><th>Value</th></tr></thead>
            <tbody>
              <tr><td>Created</td><td>${sum.Created}</td></tr>
              <tr><td>Sent Requests</td><td>${sum.SentRequests}</td></tr>
              <tr><td>Connected</td><td>${sum.Connected}</td></tr>
              <tr><td>Replies</td><td>${sum.Replies}</td></tr>
              <tr><td>Positive Replies</td><td>${sum.PositiveReplies}</td></tr>
              <tr><td>Events</td><td>${sum.Events}</td></tr>
              <tr><td>CR (Events/Created)</td><td>${cr.toFixed(2)}%</td></tr>
              <tr><td>C‚ÜíS (Connected/Sent)</td><td>${sentToConn.toFixed(2)}%</td></tr>
              <tr><td>P‚ÜíR (Positive/Replies)</td><td>${posToRep.toFixed(2)}%</td></tr>
            </tbody>
          </table>
        </div>`;
      document.getElementById('countrySummary').innerHTML = summaryHtml;
      document.getElementById('countryModalTitle').textContent = `Country Insight ‚Äî ${countryName}`;

      // monthly chart
      const monthly = aggregateCountryMonthly(countryName, rows, from, to);
      if (chartRefs.countryMonthlyPaired) chartRefs.countryMonthlyPaired.destroy();
      chartRefs.countryMonthlyPaired = renderPairedBarChart(
        document.getElementById('countryMonthlyPaired'),
        monthly.months,
        'Created',
        monthly.created,
        'Events',
        monthly.events
      );

      // top generators
      const top = aggregateCountryTopGenerators(countryName, rows, from, to, 5);
      let topHtml = '<div class="section-break"><div class="label">Top 5 Generators</div></div>';
      topHtml += '<table class="summary-table">';
      topHtml += '<thead><tr><th>Name</th><th>Created</th><th>Events</th><th>CR%</th></tr></thead><tbody>';
      for (const t of top) {
        topHtml += `<tr><td>${t.name}</td><td>${t.Created}</td><td>${t.Events}</td><td>${t.cr.toFixed(2)}%</td></tr>`;
      }
      topHtml += '</tbody></table>';
      document.getElementById('countryTopGenerators').innerHTML = topHtml;

      // show modal
      const countryOverlay = document.getElementById('countryModalOverlay');
      countryOverlay.style.display = 'flex';
      document.body.style.overflow = 'hidden';
    }

    // ===== Lead Insight helpers =====
    function aggregateLeadSummary(leadName, rows, fromDate, toDate) {
      const acc = { Created: 0, SentRequests: 0, Connected: 0, Replies: 0, PositiveReplies: 0, Events: 0 };
      for (const r of rows) {
        const name = r.Name || 'Unknown';
        if (name !== leadName) continue;
        const d = parseDdMmYyyyToDate(r.Date);
        if (!d) continue;
        if (fromDate && d < fromDate) continue;
        if (toDate && d > toDate) continue;
        acc.Created += Number(r['Created'] || 0);
        acc.SentRequests += Number(r['Sent Requests'] || 0);
        acc.Connected += Number(r['Connected'] || 0);
        acc.Replies += Number(r['Total replies'] || 0);
        acc.PositiveReplies += Number(r['Positive Replies'] || 0);
        acc.Events += Number(r['Events Created'] || 0);
      }
      return acc;
    }

    function aggregateLeadMonthly(leadName, rows, fromDate, toDate) {
      const byMonth = {};
      for (const r of rows) {
        const name = r.Name || 'Unknown';
        if (name !== leadName) continue;
        const d = parseDdMmYyyyToDate(r.Date);
        if (!d) continue;
        if (fromDate && d < fromDate) continue;
        if (toDate && d > toDate) continue;
        const key = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`;
        if (!byMonth[key]) byMonth[key] = { Created: 0, Events: 0 };
        byMonth[key].Created += Number(r['Created'] || 0);
        byMonth[key].Events += Number(r['Events Created'] || 0);
      }
      const months = Object.keys(byMonth).sort();
      return { months, created: months.map(m => byMonth[m].Created), events: months.map(m => byMonth[m].Events) };
    }

    function aggregateLeadTopCountries(leadName, rows, fromDate, toDate, limit = 5) {
      const byCountry = {};
      for (const r of rows) {
        const name = r.Name || 'Unknown';
        if (name !== leadName) continue;
        const d = parseDdMmYyyyToDate(r.Date);
        if (!d) continue;
        if (fromDate && d < fromDate) continue;
        if (toDate && d > toDate) continue;
        const country = r.Country || 'Unknown';
        if (!byCountry[country]) byCountry[country] = { Created: 0, Events: 0 };
        byCountry[country].Created += Number(r['Created'] || 0);
        byCountry[country].Events += Number(r['Events Created'] || 0);
      }
      const entries = Object.entries(byCountry).map(([country, v]) => ({ country, ...v, cr: v.Created > 0 ? (v.Events / v.Created) * 100 : 0 }));
      entries.sort((a,b) => b.cr - a.cr || b.Events - a.Events);
      return entries.slice(0, limit);
    }

    function openLeadInsight(leadName, rows) {
      const from = new Date(document.getElementById('fromDate').value);
      const to = new Date(document.getElementById('toDate').value);
      from.setHours(0,0,0,0);
      to.setHours(23,59,59,999);

      const sum = aggregateLeadSummary(leadName, rows, from, to);
      const cr = sum.Created > 0 ? (sum.Events / sum.Created) * 100 : 0;
      const sentToConn = sum.SentRequests > 0 ? (sum.Connected / sum.SentRequests) * 100 : 0;
      const posToRep = sum.Replies > 0 ? (sum.PositiveReplies / sum.Replies) * 100 : 0;
      const summaryHtml = `
        <div class="summary-table-wrapper">
          <table class="summary-table">
            <thead><tr><th>Metric</th><th>Value</th></tr></thead>
            <tbody>
              <tr><td>Created</td><td>${sum.Created}</td></tr>
              <tr><td>Sent Requests</td><td>${sum.SentRequests}</td></tr>
              <tr><td>Connected</td><td>${sum.Connected}</td></tr>
              <tr><td>Replies</td><td>${sum.Replies}</td></tr>
              <tr><td>Positive Replies</td><td>${sum.PositiveReplies}</td></tr>
              <tr><td>Events</td><td>${sum.Events}</td></tr>
              <tr><td>CR (Events/Created)</td><td>${cr.toFixed(2)}%</td></tr>
              <tr><td>C‚ÜíS (Connected/Sent)</td><td>${sentToConn.toFixed(2)}%</td></tr>
              <tr><td>P‚ÜíR (Positive/Replies)</td><td>${posToRep.toFixed(2)}%</td></tr>
            </tbody>
          </table>
        </div>`;
      document.getElementById('leadSummary').innerHTML = summaryHtml;
      document.getElementById('leadModalTitle').textContent = `Lead Insight ‚Äî ${leadName}`;

      const monthly = aggregateLeadMonthly(leadName, rows, from, to);
      if (chartRefs.leadMonthlyPaired) chartRefs.leadMonthlyPaired.destroy();
      chartRefs.leadMonthlyPaired = renderPairedBarChart(
        document.getElementById('leadMonthlyPaired'),
        monthly.months,
        'Created',
        monthly.created,
        'Events',
        monthly.events
      );

      const top = aggregateLeadTopCountries(leadName, rows, from, to, 5);
      let topHtml = '<div class="section-break"><div class="label">Top 5 Countries</div></div>';
      topHtml += '<table class="summary-table">';
      topHtml += '<thead><tr><th>Country</th><th>Created</th><th>Events</th><th>CR%</th></tr></thead><tbody>';
      for (const t of top) {
        topHtml += `<tr><td>${t.country}</td><td>${t.Created}</td><td>${t.Events}</td><td>${t.cr.toFixed(2)}%</td></tr>`;
      }
      topHtml += '</tbody></table>';
      document.getElementById('leadTopCountries').innerHTML = topHtml;

      const leadOverlay = document.getElementById('leadModalOverlay');
      leadOverlay.style.display = 'flex';
      document.body.style.overflow = 'hidden';
    }
  </script>
</body>
</html>

